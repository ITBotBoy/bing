{"ast":null,"code":"// download.js v4.2, by dandavis; 2008-2016. [MIT] see http://danml.com/download.html for tests/usage\n// v1 landed a FF+Chrome compat way of downloading strings to local un-named files, upgraded to use a hidden frame and optional mime\n// v2 added named files via a[download], msSaveBlob, IE (10+) support, and window.URL support for larger+faster saves than dataURLs\n// v3 added dataURL and Blob Input, bind-toggle arity, and legacy dataURL fallback was improved with force-download mime and base64 support. 3.1 improved safari handling.\n// v4 adds AMD/UMD, commonJS, and plain browser support\n// v4.1 adds url download capability via solo URL argument (same domain/CORS only)\n// v4.2 adds semantic variable names, long (over 2MB) dataURL support, and hidden by default temp anchors\n// https://github.com/rndme/download\nexport default function download(data, strFileName, strMimeType) {\n  let self = window,\n      // this script is only for browsers anyway...\n  defaultMime = 'application/octet-stream',\n      // this default mime also triggers iframe downloads\n  mimeType = strMimeType || defaultMime,\n      payload = data,\n      url = data,\n      anchor = document.createElement('a'),\n      toString = function (a) {\n    return String(a);\n  },\n      myBlob = self.Blob || self.MozBlob || self.WebKitBlob || toString,\n      fileName = strFileName || 'download',\n      blob,\n      reader;\n\n  myBlob = myBlob.call ? myBlob.bind(self) : Blob;\n\n  if (String(this) === 'true') {\n    // reverse arguments, allowing download.bind(true, \"text/xml\", \"export.xml\") to act as a callback\n    payload = [payload, mimeType];\n    mimeType = payload[0];\n    payload = payload[1];\n  }\n\n  if (url && url.length < 2048) {\n    // if no filename and no mime, assume a url was passed as the only argument\n    anchor.href = url; // assign href prop to temp anchor\n\n    if (anchor.href.indexOf(url) !== -1) {\n      // if the browser determines that it's a potentially valid url path:\n      const ajax = new XMLHttpRequest();\n      ajax.open('GET', url, true);\n      ajax.responseType = 'blob';\n\n      ajax.onload = function (e) {\n        download(e.target.response, fileName, defaultMime);\n      };\n\n      setTimeout(() => {\n        ajax.send();\n      }, 0); // allows setting custom ajax headers using the return:\n\n      return ajax;\n    } // end if valid url?\n\n  } // end if url?\n  // go ahead and download dataURLs right away\n\n\n  if (/^data:([\\w+-]+\\/[\\w+.-]+)?[,;]/.test(payload)) {\n    if (payload.length > 1024 * 1024 * 1.999 && myBlob !== toString) {\n      payload = dataUrlToBlob(payload);\n      mimeType = payload.type || defaultMime;\n    } else {\n      return navigator.msSaveBlob ? // IE10 can't do a[download], only Blobs:\n      navigator.msSaveBlob(dataUrlToBlob(payload), fileName) : saver(payload); // everyone else can save dataURLs un-processed\n    }\n  } else {\n    // not data url, is it a string with special needs?\n    if (/([\\x80-\\xff])/.test(payload)) {\n      let i = 0,\n          tempUiArr = new Uint8Array(payload.length),\n          mx = tempUiArr.length;\n\n      for (i; i < mx; ++i) tempUiArr[i] = payload.charCodeAt(i);\n\n      payload = new myBlob([tempUiArr], {\n        type: mimeType\n      });\n    }\n  }\n\n  blob = payload instanceof myBlob ? payload : new myBlob([payload], {\n    type: mimeType\n  });\n\n  function dataUrlToBlob(strUrl) {\n    let parts = strUrl.split(/[:;,]/),\n        type = parts[1],\n        decoder = parts[2] == 'base64' ? atob : decodeURIComponent,\n        binData = decoder(parts.pop()),\n        mx = binData.length,\n        i = 0,\n        uiArr = new Uint8Array(mx);\n\n    for (i; i < mx; ++i) uiArr[i] = binData.charCodeAt(i);\n\n    return new myBlob([uiArr], {\n      type\n    });\n  }\n\n  function saver(url, winMode) {\n    if ('download' in anchor) {\n      // html5 A[download]\n      anchor.href = url;\n      anchor.setAttribute('download', fileName);\n      anchor.className = 'download-js-link';\n      anchor.innerHTML = 'downloading...';\n      anchor.style.display = 'none';\n      document.body.appendChild(anchor);\n      setTimeout(() => {\n        anchor.click();\n        document.body.removeChild(anchor);\n\n        if (winMode === true) {\n          setTimeout(() => {\n            self.URL.revokeObjectURL(anchor.href);\n          }, 250);\n        }\n      }, 66);\n      return true;\n    } // handle non-a[download] safari as best we can:\n\n\n    if (/(Version)\\/(\\d+)\\.(\\d+)(?:\\.(\\d+))?.*Safari\\//.test(navigator.userAgent)) {\n      if (/^data:/.test(url)) url = `data:${url.replace(/^data:([\\w\\/\\-\\+]+)/, defaultMime)}`;\n\n      if (!window.open(url)) {\n        // popup blocked, offer direct download:\n        if (window.confirm('Displaying New Document\\n\\nUse Save As... to download, then click back to return to this page.')) {\n          window.location.href = url;\n        }\n      }\n\n      return true;\n    } // do iframe dataURL download (old ch+FF):\n\n\n    const f = document.createElement('iframe');\n    document.body.appendChild(f);\n\n    if (!winMode && /^data:/.test(url)) {\n      // force a mime that will download:\n      url = `data:${url.replace(/^data:([\\w\\/\\-\\+]+)/, defaultMime)}`;\n    }\n\n    f.src = url;\n    setTimeout(() => {\n      document.body.removeChild(f);\n    }, 333);\n  } // end saver\n\n\n  if (navigator.msSaveBlob) {\n    // IE10+ : (has Blob, but not a[download] or URL)\n    return navigator.msSaveBlob(blob, fileName);\n  }\n\n  if (self.URL) {\n    // simple fast and modern way using Blob and URL:\n    saver(self.URL.createObjectURL(blob), true);\n  } else {\n    // handle non-Blob()+non-URL browsers:\n    if (typeof blob === 'string' || blob.constructor === toString) {\n      try {\n        return saver(`data:${mimeType};base64,${self.btoa(blob)}`);\n      } catch (y) {\n        return saver(`data:${mimeType},${encodeURIComponent(blob)}`);\n      }\n    } // Blob but not URL support:\n\n\n    reader = new FileReader();\n\n    reader.onload = function (e) {\n      saver(this.result);\n    };\n\n    reader.readAsDataURL(blob);\n  }\n\n  return true;\n}","map":{"version":3,"sources":["E:/Future/bing/util/download.js"],"names":["download","data","strFileName","strMimeType","self","window","defaultMime","mimeType","payload","url","anchor","document","createElement","toString","a","String","myBlob","Blob","MozBlob","WebKitBlob","fileName","blob","reader","call","bind","length","href","indexOf","ajax","XMLHttpRequest","open","responseType","onload","e","target","response","setTimeout","send","test","dataUrlToBlob","type","navigator","msSaveBlob","saver","i","tempUiArr","Uint8Array","mx","charCodeAt","strUrl","parts","split","decoder","atob","decodeURIComponent","binData","pop","uiArr","winMode","setAttribute","className","innerHTML","style","display","body","appendChild","click","removeChild","URL","revokeObjectURL","userAgent","replace","confirm","location","f","src","createObjectURL","constructor","btoa","y","encodeURIComponent","FileReader","result","readAsDataURL"],"mappings":"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","sourcesContent":["// download.js v4.2, by dandavis; 2008-2016. [MIT] see http://danml.com/download.html for tests/usage\r\n// v1 landed a FF+Chrome compat way of downloading strings to local un-named files, upgraded to use a hidden frame and optional mime\r\n// v2 added named files via a[download], msSaveBlob, IE (10+) support, and window.URL support for larger+faster saves than dataURLs\r\n// v3 added dataURL and Blob Input, bind-toggle arity, and legacy dataURL fallback was improved with force-download mime and base64 support. 3.1 improved safari handling.\r\n// v4 adds AMD/UMD, commonJS, and plain browser support\r\n// v4.1 adds url download capability via solo URL argument (same domain/CORS only)\r\n// v4.2 adds semantic variable names, long (over 2MB) dataURL support, and hidden by default temp anchors\r\n// https://github.com/rndme/download\r\n\r\nexport default function download(data, strFileName, strMimeType) {\r\n  let self = window, // this script is only for browsers anyway...\r\n    defaultMime = 'application/octet-stream', // this default mime also triggers iframe downloads\r\n    mimeType = strMimeType || defaultMime,\r\n    payload = data,\r\n    url = data,\r\n    anchor = document.createElement('a'),\r\n    toString = function (a) { return String(a); },\r\n    myBlob = (self.Blob || self.MozBlob || self.WebKitBlob || toString),\r\n    fileName = strFileName || 'download',\r\n    blob,\r\n    reader;\r\n  myBlob = myBlob.call ? myBlob.bind(self) : Blob;\r\n\r\n  if (String(this) === 'true') { // reverse arguments, allowing download.bind(true, \"text/xml\", \"export.xml\") to act as a callback\r\n    payload = [payload, mimeType];\r\n    mimeType = payload[0];\r\n    payload = payload[1];\r\n  }\r\n\r\n\r\n  if (url && url.length < 2048) { // if no filename and no mime, assume a url was passed as the only argument\r\n    anchor.href = url; // assign href prop to temp anchor\r\n    if (anchor.href.indexOf(url) !== -1) { // if the browser determines that it's a potentially valid url path:\r\n      const ajax = new XMLHttpRequest();\r\n      ajax.open('GET', url, true);\r\n      ajax.responseType = 'blob';\r\n      ajax.onload = function (e) {\r\n        download(e.target.response, fileName, defaultMime);\r\n      };\r\n      setTimeout(() => { ajax.send(); }, 0); // allows setting custom ajax headers using the return:\r\n      return ajax;\r\n    } // end if valid url?\r\n  } // end if url?\r\n\r\n\r\n  // go ahead and download dataURLs right away\r\n  if (/^data:([\\w+-]+\\/[\\w+.-]+)?[,;]/.test(payload)) {\r\n    if (payload.length > (1024 * 1024 * 1.999) && myBlob !== toString) {\r\n      payload = dataUrlToBlob(payload);\r\n      mimeType = payload.type || defaultMime;\r\n    } else {\r\n      return navigator.msSaveBlob ?  // IE10 can't do a[download], only Blobs:\r\n        navigator.msSaveBlob(dataUrlToBlob(payload), fileName) :\r\n        saver(payload); // everyone else can save dataURLs un-processed\r\n    }\r\n  } else { // not data url, is it a string with special needs?\r\n    if (/([\\x80-\\xff])/.test(payload)) {\r\n      let i = 0,\r\n        tempUiArr = new Uint8Array(payload.length),\r\n        mx = tempUiArr.length;\r\n      for (i; i < mx; ++i) tempUiArr[i] = payload.charCodeAt(i);\r\n      payload = new myBlob([tempUiArr], { type: mimeType });\r\n    }\r\n  }\r\n  blob = payload instanceof myBlob ?\r\n    payload :\r\n    new myBlob([payload], { type: mimeType });\r\n\r\n\r\n  function dataUrlToBlob(strUrl) {\r\n    let parts = strUrl.split(/[:;,]/),\r\n      type = parts[1],\r\n      decoder = parts[2] == 'base64' ? atob : decodeURIComponent,\r\n      binData = decoder(parts.pop()),\r\n      mx = binData.length,\r\n      i = 0,\r\n      uiArr = new Uint8Array(mx);\r\n\r\n    for (i; i < mx; ++i) uiArr[i] = binData.charCodeAt(i);\r\n\r\n    return new myBlob([uiArr], { type });\r\n  }\r\n\r\n  function saver(url, winMode) {\r\n    if ('download' in anchor) { // html5 A[download]\r\n      anchor.href = url;\r\n      anchor.setAttribute('download', fileName);\r\n      anchor.className = 'download-js-link';\r\n      anchor.innerHTML = 'downloading...';\r\n      anchor.style.display = 'none';\r\n      document.body.appendChild(anchor);\r\n      setTimeout(() => {\r\n        anchor.click();\r\n        document.body.removeChild(anchor);\r\n        if (winMode === true) { setTimeout(() => { self.URL.revokeObjectURL(anchor.href); }, 250); }\r\n      }, 66);\r\n      return true;\r\n    }\r\n\r\n    // handle non-a[download] safari as best we can:\r\n    if (/(Version)\\/(\\d+)\\.(\\d+)(?:\\.(\\d+))?.*Safari\\//.test(navigator.userAgent)) {\r\n      if (/^data:/.test(url))\turl = `data:${url.replace(/^data:([\\w\\/\\-\\+]+)/, defaultMime)}`;\r\n      if (!window.open(url)) { // popup blocked, offer direct download:\r\n        if (window.confirm('Displaying New Document\\n\\nUse Save As... to download, then click back to return to this page.')) { window.location.href = url; }\r\n      }\r\n      return true;\r\n    }\r\n\r\n    // do iframe dataURL download (old ch+FF):\r\n    const f = document.createElement('iframe');\r\n    document.body.appendChild(f);\r\n\r\n    if (!winMode && /^data:/.test(url)) { // force a mime that will download:\r\n      url = `data:${url.replace(/^data:([\\w\\/\\-\\+]+)/, defaultMime)}`;\r\n    }\r\n    f.src = url;\r\n    setTimeout(() => { document.body.removeChild(f); }, 333);\r\n  }// end saver\r\n\r\n  if (navigator.msSaveBlob) { // IE10+ : (has Blob, but not a[download] or URL)\r\n    return navigator.msSaveBlob(blob, fileName);\r\n  }\r\n\r\n  if (self.URL) { // simple fast and modern way using Blob and URL:\r\n    saver(self.URL.createObjectURL(blob), true);\r\n  } else {\r\n    // handle non-Blob()+non-URL browsers:\r\n    if (typeof blob === 'string' || blob.constructor === toString) {\r\n      try {\r\n        return saver(`data:${mimeType};base64,${self.btoa(blob)}`);\r\n      } catch (y) {\r\n        return saver(`data:${mimeType},${encodeURIComponent(blob)}`);\r\n      }\r\n    }\r\n\r\n    // Blob but not URL support:\r\n    reader = new FileReader();\r\n    reader.onload = function (e) {\r\n      saver(this.result);\r\n    };\r\n    reader.readAsDataURL(blob);\r\n  }\r\n  return true;\r\n}"]},"metadata":{},"sourceType":"module"}