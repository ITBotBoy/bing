{"ast":null,"code":"// download.js v4.2, by dandavis; 2008-2016. [MIT] see http://danml.com/download.html for tests/usage\n// v1 landed a FF+Chrome compat way of downloading strings to local un-named files, upgraded to use a hidden frame and optional mime\n// v2 added named files via a[download], msSaveBlob, IE (10+) support, and window.URL support for larger+faster saves than dataURLs\n// v3 added dataURL and Blob Input, bind-toggle arity, and legacy dataURL fallback was improved with force-download mime and base64 support. 3.1 improved safari handling.\n// v4 adds AMD/UMD, commonJS, and plain browser support\n// v4.1 adds url download capability via solo URL argument (same domain/CORS only)\n// v4.2 adds semantic variable names, long (over 2MB) dataURL support, and hidden by default temp anchors\n// https://github.com/rndme/download\nexport default function download(data, strFileName, strMimeType) {\n  let self = window,\n      // this script is only for browsers anyway...\n  defaultMime = 'application/octet-stream',\n      // this default mime also triggers iframe downloads\n  mimeType = strMimeType || defaultMime,\n      payload = data,\n      url = data,\n      anchor = document.createElement('a'),\n      toString = function (a) {\n    return String(a);\n  },\n      myBlob = self.Blob || self.MozBlob || self.WebKitBlob || toString,\n      fileName = strFileName || 'download',\n      blob,\n      reader;\n\n  myBlob = myBlob.call ? myBlob.bind(self) : Blob;\n\n  if (String(this) === 'true') {\n    // reverse arguments, allowing download.bind(true, \"text/xml\", \"export.xml\") to act as a callback\n    payload = [payload, mimeType];\n    mimeType = payload[0];\n    payload = payload[1];\n  }\n\n  if (url && url.length < 2048) {\n    // if no filename and no mime, assume a url was passed as the only argument\n    anchor.href = url; // assign href prop to temp anchor\n\n    if (anchor.href.indexOf(url) !== -1) {\n      // if the browser determines that it's a potentially valid url path:\n      const ajax = new XMLHttpRequest();\n      ajax.open('GET', url, true);\n      ajax.responseType = 'blob';\n\n      ajax.onload = function (e) {\n        download(e.target.response, fileName, defaultMime);\n      };\n\n      setTimeout(() => {\n        ajax.send();\n      }, 0); // allows setting custom ajax headers using the return:\n\n      return ajax;\n    } // end if valid url?\n\n  } // end if url?\n  // go ahead and download dataURLs right away\n\n\n  if (/^data:([\\w+-]+\\/[\\w+.-]+)?[,;]/.test(payload)) {\n    if (payload.length > 1024 * 1024 * 1.999 && myBlob !== toString) {\n      payload = dataUrlToBlob(payload);\n      mimeType = payload.type || defaultMime;\n    } else {\n      return navigator.msSaveBlob ? // IE10 can't do a[download], only Blobs:\n      navigator.msSaveBlob(dataUrlToBlob(payload), fileName) : saver(payload); // everyone else can save dataURLs un-processed\n    }\n  } else {\n    // not data url, is it a string with special needs?\n    if (/([\\x80-\\xff])/.test(payload)) {\n      let i = 0,\n          tempUiArr = new Uint8Array(payload.length),\n          mx = tempUiArr.length;\n\n      for (i; i < mx; ++i) tempUiArr[i] = payload.charCodeAt(i);\n\n      payload = new myBlob([tempUiArr], {\n        type: mimeType\n      });\n    }\n  }\n\n  blob = payload instanceof myBlob ? payload : new myBlob([payload], {\n    type: mimeType\n  });\n\n  function dataUrlToBlob(strUrl) {\n    let parts = strUrl.split(/[:;,]/),\n        type = parts[1],\n        decoder = parts[2] == 'base64' ? atob : decodeURIComponent,\n        binData = decoder(parts.pop()),\n        mx = binData.length,\n        i = 0,\n        uiArr = new Uint8Array(mx);\n\n    for (i; i < mx; ++i) uiArr[i] = binData.charCodeAt(i);\n\n    return new myBlob([uiArr], {\n      type\n    });\n  }\n\n  function saver(url, winMode) {\n    if ('download' in anchor) {\n      // html5 A[download]\n      anchor.href = url;\n      anchor.setAttribute('download', fileName);\n      anchor.className = 'download-js-link';\n      anchor.innerHTML = 'downloading...';\n      anchor.style.display = 'none';\n      document.body.appendChild(anchor);\n      setTimeout(() => {\n        anchor.click();\n        document.body.removeChild(anchor);\n\n        if (winMode === true) {\n          setTimeout(() => {\n            self.URL.revokeObjectURL(anchor.href);\n          }, 250);\n        }\n      }, 66);\n      return true;\n    } // handle non-a[download] safari as best we can:\n\n\n    if (/(Version)\\/(\\d+)\\.(\\d+)(?:\\.(\\d+))?.*Safari\\//.test(navigator.userAgent)) {\n      if (/^data:/.test(url)) url = `data:${url.replace(/^data:([\\w\\/\\-\\+]+)/, defaultMime)}`;\n\n      if (!window.open(url)) {\n        // popup blocked, offer direct download:\n        if (window.confirm('Displaying New Document\\n\\nUse Save As... to download, then click back to return to this page.')) {\n          window.location.href = url;\n        }\n      }\n\n      return true;\n    } // do iframe dataURL download (old ch+FF):\n\n\n    const f = document.createElement('iframe');\n    document.body.appendChild(f);\n\n    if (!winMode && /^data:/.test(url)) {\n      // force a mime that will download:\n      url = `data:${url.replace(/^data:([\\w\\/\\-\\+]+)/, defaultMime)}`;\n    }\n\n    f.src = url;\n    setTimeout(() => {\n      document.body.removeChild(f);\n    }, 333);\n  } // end saver\n\n\n  if (navigator.msSaveBlob) {\n    // IE10+ : (has Blob, but not a[download] or URL)\n    return navigator.msSaveBlob(blob, fileName);\n  }\n\n  if (self.URL) {\n    // simple fast and modern way using Blob and URL:\n    saver(self.URL.createObjectURL(blob), true);\n  } else {\n    // handle non-Blob()+non-URL browsers:\n    if (typeof blob === 'string' || blob.constructor === toString) {\n      try {\n        return saver(`data:${mimeType};base64,${self.btoa(blob)}`);\n      } catch (y) {\n        return saver(`data:${mimeType},${encodeURIComponent(blob)}`);\n      }\n    } // Blob but not URL support:\n\n\n    reader = new FileReader();\n\n    reader.onload = function (e) {\n      saver(this.result);\n    };\n\n    reader.readAsDataURL(blob);\n  }\n\n  return true;\n}","map":null,"metadata":{},"sourceType":"module"}